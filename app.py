# THIS CODE WAS COMPLETELY GENERATED BY GEMINI PRO

import streamlit as st
import chess
import chess.svg
import base64
import time
from src.game_engine import ChessEngine

# --- Configuration ---
MODEL_PATH = "checkpoints/final_model.safetensors"  # Update this to your actual weights file
st.set_page_config(page_title="MLX Chess", page_icon="♟️", layout="centered")

# --- CSS for Board Centering ---
st.markdown(
    """
    <style>
    .chess-board {
        display: flex;
        justify_content: center;
        margin-bottom: 20px;
    }
    </style>
    """,
    unsafe_allow_html=True,
)

# --- 1. Load Engine (Cached) ---
@st.cache_resource
def load_engine():
    """
    Loads the MLX model once and caches it to avoid reloading 
    on every interaction.
    """
    # Ensure this path points to your saved weights
    return ChessEngine(MODEL_PATH)

try:
    engine = load_engine()
except Exception as e:
    st.error(f"Error loading model: {e}")
    st.stop()

# --- 2. Session State Management ---
if "board" not in st.session_state:
    st.session_state.board = chess.Board()
if "game_over" not in st.session_state:
    st.session_state.game_over = False
if "last_eval" not in st.session_state:
    st.session_state.last_eval = 0.0
if "history" not in st.session_state:
    st.session_state.history = []

# --- 3. Helper Functions ---

def render_board(board):
    """Renders the board as an SVG image."""
    # We highlight the last move if it exists
    board_svg = chess.svg.board(
        board=board, 
        lastmove=board.peek() if board.move_stack else None,
        size=400
    )
    # Encode to base64 to display cleanly in markdown
    b64 = base64.b64encode(board_svg.encode('utf-8')).decode("utf-8")
    html = f'<div class="chess-board"><img src="data:image/svg+xml;base64,{b64}"/></div>'
    st.markdown(html, unsafe_allow_html=True)

def reset_game():
    st.session_state.board = chess.Board()
    st.session_state.game_over = False
    st.session_state.last_eval = 0.0
    st.session_state.history = []

def make_ai_move(temperature):
    """Triggers the engine to make a move."""
    board = st.session_state.board
    
    if board.is_game_over():
        st.session_state.game_over = True
        return

    with st.spinner("Thinking..."):
        # The engine handles the perspective flip internally
        move, val = engine.get_best_move(board, temperature=temperature)
        
        if move is None:
            st.error("AI could not find a legal move (Resign).")
            st.session_state.game_over = True
        else:
            board.push(move)
            st.session_state.last_eval = val
            st.session_state.history.append(f"AI: {move.uci()} (Eval: {val:.2f})")

# --- 4. Sidebar Controls ---
with st.sidebar:
    st.title("Settings")
    
    temperature = st.slider(
        "Temperature (Creativity)", 
        min_value=0.0, 
        max_value=1.0, 
        value=0.0,
        help="0.0 = Always pick best move. Higher values add randomness."
    )
    
    if st.button("New Game"):
        reset_game()
        st.rerun()

    st.markdown("---")
    st.write("### Move History")
    for item in reversed(st.session_state.history[-10:]):
        st.text(item)

# --- 5. Main Game Interface ---
st.title("♟️ Play against MLX ChessNet")

# Status Display
col1, col2 = st.columns(2)
with col1:
    turn_text = "White to Move" if st.session_state.board.turn == chess.WHITE else "Black to Move"
    st.subheader(f"{turn_text}")
with col2:
    # Value is from -1 (Loss) to 1 (Win) from current player's view
    eval_val = st.session_state.last_eval
    st.metric(label="Model Confidence", value=f"{eval_val:.2f}")

# Render the Board
render_board(st.session_state.board)

# Game Logic
if st.session_state.board.is_game_over():
    st.success(f"Game Over! Result: {st.session_state.board.result()}")
else:
    # Human Move Input
    # We use a form so the page doesn't reload while typing
    with st.form("human_move_form"):
        col_input, col_btn = st.columns([3, 1])
        with col_input:
            move_input = st.text_input("Enter your move (e.g., e2e4, Nf3)", key="move_input")
        with col_btn:
            submit_move = st.form_submit_button("Play")

    if submit_move and move_input:
        board = st.session_state.board
        try:
            # Try to parse UCI (e2e4) first, then SAN (Nf3)
            try:
                move = chess.Move.from_uci(move_input)
            except:
                move = board.parse_san(move_input)
            
            if move in board.legal_moves:
                board.push(move)
                st.session_state.history.append(f"You: {move.uci()}")
                st.rerun() # Rerun to update board immediately before AI thinks
            else:
                st.error("Illegal move.")
        except ValueError:
            st.error("Invalid move format. Use UCI (e2e4) or SAN (Nf3).")

# --- 6. AI Auto-Response Trigger ---
# If it is NOT the human's turn (assuming Human is White for now), trigger AI
# You can add a toggle to swap sides if you want.
if not st.session_state.game_over and st.session_state.board.turn == chess.BLACK:
    # Add a tiny delay so the UI renders the user's move first
    time.sleep(0.5) 
    make_ai_move(temperature)
    st.rerun()