'''
Please refer to README.md for more informantion about the tensor channels.
'''

import chess
import chess.pgn
import numpy as np
import h5py
import os
import random
import time
from tqdm import tqdm

class ChessConverter:
    '''
    Transforms the board to a tensor (x)
    Transforms movements to index (y, policy)
    Computes the result value (y, value)
    '''

    def __init__(self):
        # maps pieces to channel indexes
        self.piece_map = {
            chess.PAWN: 0, chess.KNIGHT: 1, chess.BISHOP: 2,
            chess.ROOK: 3, chess.QUEEN: 4, chess.KING: 5
        }

    def board_to_tensor(self, board):
        '''
        parses a chess board to a tensor with shape (14, 8, 8) with cannonic rotation (always from player's perspective)
        '''
    
        # creates an empty tensor for the board
        planes = np.zeros((14, 8, 8), dtype=np.float32)
        
        us = board.turn
        them = not us
        
        # populates the tensor with the pieces
        for piece_type, channel_idx in self.piece_map.items():
            # player's pieces here
            for sq in board.pieces(piece_type, us):
                # if player's playing black, rotate the index 180 degrees (0->63)
                real_sq = sq if us == chess.WHITE else 63 - sq
                row, col = divmod(real_sq, 8)
                planes[channel_idx, row, col] = 1.0
            
            # opponent's pieces. added +6 to the channels idx to match with the opponents pieces positions
            for sq in board.pieces(piece_type, them):
                real_sq = sq if us == chess.WHITE else 63 - sq
                row, col = divmod(real_sq, 8)
                planes[channel_idx + 6, row, col] = 1.0

        # game extra informantion
        # channel 12: castling = 1 if possible else 0
        if board.has_kingside_castling_rights(us) or board.has_queenside_castling_rights(us):
            planes[12, :, :] = 1.0
            
        # channel 13: En Passant, if exists the squre for it
        if board.ep_square:
            ep_sq = board.ep_square if us == chess.WHITE else 63 - board.ep_square
            row, col = divmod(ep_sq, 8)
            planes[13, row, col] = 1.0

        return planes

    def encode_move(self, move, turn):
        '''
        Encodes an UCI movement to the index (0-4095) using the formula index = (origen * 64) destiny
        If the board is rotated (turn for black), the movement is also rotated
        '''
        src = move.from_square
        dst = move.to_square
        
        if turn == chess.BLACK:
            src = 63 - src
            dst = 63 - dst
            
        return src * 64 + dst

    def get_result_value(self, game, turn):
        '''
        Gets the result (value) relative to the current perspective.
        1.0 if the current perspective wins, -1.0 if loses, 0.0 if draw
        '''
        header_result = game.headers.get("Result", "*")
        if header_result == "1-0":
            return 1.0 if turn == chess.WHITE else -1.0
        elif header_result == "0-1":
            return -1.0 if turn == chess.WHITE else 1.0
        elif header_result == "1/2-1/2":
            return 0.0
        return 0.0

class PGNProcessor:
    """
    Clase encargada de leer PGNs, filtrar, hacer sampling y escribir a disco.
    Usa buffering para no saturar la RAM.

    THIS CLASS WAS FULLY GENERATED BY GEMINI PRO
    """
    def __init__(self, converter, min_elo=2000, samples_per_game=10, buffer_size=5000):
        self.converter = converter
        self.min_elo = min_elo
        self.samples_per_game = samples_per_game
        self.buffer_size = buffer_size
        
        # Buffers temporales en RAM
        self.buf_x = []
        self.buf_p = []
        self.buf_v = []

    def filter_game(self, game):
        """Filtra por ELO y Tiempo (si está disponible)"""
        headers = game.headers
        try:
            w_elo = int(headers.get("WhiteElo", 0))
            b_elo = int(headers.get("BlackElo", 0))
            if w_elo < self.min_elo or b_elo < self.min_elo:
                return False
        except:
            pass # Si falla conversión, decidimos si mantener o descartar. Aquí mantenemos.
        
        # Descartar Bullet (Tiempo base < 60s)
        tc = headers.get("TimeControl", "")
        if tc and "+" in tc:
            try:
                if int(tc.split("+")[0]) < 60: return False
            except: pass
            
        return True

    def process_file(self, pgn_path, output_h5_path):
        """
        Lee un archivo PGN desde disco y guarda tensores en .h5
        """
        print(f"Abriendo archivo PGN: {pgn_path}")
        
        # Inicializar archivo HDF5
        with h5py.File(output_h5_path, 'w') as f:
            # Datasets extensibles (maxshape=None)
            dset_x = f.create_dataset('x', shape=(0, 14, 8, 8), maxshape=(None, 14, 8, 8), dtype='float32', chunks=True)
            dset_p = f.create_dataset('policy', shape=(0,), maxshape=(None,), dtype='int64', chunks=True)
            dset_v = f.create_dataset('value', shape=(0,), maxshape=(None,), dtype='float32', chunks=True)

            games_count = 0
            saved_samples = 0
            
            # Abrir archivo PGN
            try:
                pgn_file = open(pgn_path, encoding='utf-8')
            except FileNotFoundError:
                print(f"Error: No se encontró el archivo {pgn_path}")
                return

            # Barra de progreso (como no sabemos el total de juegos, usamos un contador simple)
            pbar = tqdm(desc="Procesando Partidas", unit=" games")
            
            while True:
                try:
                    game = chess.pgn.read_game(pgn_file)
                except Exception as e:
                    print(f"\nError leyendo juego en línea: {e}")
                    break
                
                if game is None: break # Fin del archivo

                # 1. Filtrado
                if not self.filter_game(game): 
                    pbar.update(1)
                    continue
                
                # 2. Extracción de movimientos
                board = game.board()
                moves = list(game.mainline_moves())
                
                # Filtrar partidas muy cortas
                if len(moves) < 15: 
                    pbar.update(1)
                    continue

                # 3. Sampling (Descorrelación)
                # Elegir N posiciones aleatorias
                n_moves = len(moves)
                if n_moves <= 10: 
                    pbar.update(1)
                    continue
                
                indices_to_sample = set(random.sample(
                    range(5, n_moves - 5), 
                    min(self.samples_per_game, n_moves - 10)
                ))

                # Recorrer partida para extraer samples
                current_idx = 0
                for move in moves:
                    if current_idx in indices_to_sample:
                        # Generar Tensores
                        x_tensor = self.converter.board_to_tensor(board)
                        p_label = self.converter.encode_move(move, board.turn)
                        v_label = self.converter.get_result_value(game, board.turn)

                        self.buf_x.append(x_tensor)
                        self.buf_p.append(p_label)
                        self.buf_v.append(v_label)

                    board.push(move)
                    current_idx += 1
                
                games_count += 1
                pbar.update(1)
                pbar.set_postfix({"Saved Samples": saved_samples + len(self.buf_x)})
                
                # 4. Flush al disco si el buffer está lleno
                if len(self.buf_x) >= self.buffer_size:
                    saved_samples += len(self.buf_x)
                    self._flush_buffer(dset_x, dset_p, dset_v)

            # Flush final (lo que sobró)
            if len(self.buf_x) > 0:
                saved_samples += len(self.buf_x)
                self._flush_buffer(dset_x, dset_p, dset_v)
            
            pbar.close()
            pgn_file.close()
            print(f"\n[ETL] FINALIZADO.")
            print(f" - Partidas útiles procesadas: {games_count}")
            print(f" - Muestras totales guardadas: {dset_x.shape[0]}")
            print(f" - Archivo generado: {output_h5_path}")

    def _flush_buffer(self, dset_x, dset_p, dset_v):
        """Escribe buffers en HDF5 y limpia memoria"""
        n_add = len(self.buf_x)
        if n_add == 0: return

        # Redimensionar datasets
        curr_len = dset_x.shape[0]
        new_len = curr_len + n_add
        
        dset_x.resize((new_len, 14, 8, 8))
        dset_p.resize((new_len,))
        dset_v.resize((new_len,))
        
        # Escribir
        dset_x[curr_len:new_len] = np.array(self.buf_x, dtype=np.float32)
        dset_p[curr_len:new_len] = np.array(self.buf_p, dtype=np.int64)
        dset_v[curr_len:new_len] = np.array(self.buf_v, dtype=np.float32)
        
        # Limpiar
        self.buf_x, self.buf_p, self.buf_v = [], [], []


if __name__ == "__main__":
    

    PGN_FILE_PATH = "lichess_elite_db/lichess_elite_2020-06.pgn"
    OUTPUT_H5_FILE = "dataset_ajedrez_final.h5"
    
    MIN_ELO = 2000
    SAMPLES_PER_GAME = 10
    BUFFER_SIZE = 5000 # Cuántas muestras acumular antes de escribir a disco

    if not os.path.exists(PGN_FILE_PATH):
        print(f'FILE {PGN_FILE_PATH} NOT FOUND\n')

    else:
        print('\n-- Starting transformations PGN to HDF5')
        print(f"Input: {PGN_FILE_PATH}")
        print(f"Output: {OUTPUT_H5_FILE}")
        print(f"Filters: ELO > {MIN_ELO}, Samples/Game = {SAMPLES_PER_GAME}")
        
        start_time = time.time()
        
        converter = ChessConverter()
        processor = PGNProcessor(
            converter, 
            min_elo=MIN_ELO, 
            samples_per_game=SAMPLES_PER_GAME, 
            buffer_size=BUFFER_SIZE
        )
        
        processor.process_file(PGN_FILE_PATH, OUTPUT_H5_FILE)
        
        elapsed = time.time() - start_time
        print(f"Total time: {elapsed:.2f} ss")