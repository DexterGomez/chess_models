import torch
from torch.utils.data import Dataset
import mlx.core as mx
from queue import Queue
from threading import Thread
import h5py
import os

class ChessDataset(Dataset):
    '''
    Data loader for ChessNet supervised learning
    '''

    def __init__(self, h5_path):
        self.h5_path = h5_path
        assert os.path.exists(h5_path), 'file does not exists'
        
        with h5py.File(self.h5_path, 'r') as f:
            self.length = f['x'].shape[0]
            
        self.h5_file = None

    def __len__(self):
        return self.length

    def __getitem__(self, idx):
        if self.h5_file is None:
            self.h5_file = h5py.File(self.h5_path, 'r')

        x_data = self.h5_file['x'][idx]
        p_data = self.h5_file['policy'][idx]
        v_data = self.h5_file['value'][idx]

        x = torch.from_numpy(x_data)

        p = torch.tensor(p_data, dtype=torch.long)

        v = torch.tensor(v_data, dtype=torch.float)
            
        return x, p, v
    

class AsyncDataPrefetcher:
    """
    Prefetches and converts batches to MLX arrays in a background thread.

    THIS CLASS WAS COMPLETELY GENERATED BY GEMINI PRO
    """
    def __init__(self, dataloader, queue_size=4):
        self.dataloader = dataloader
        self.queue = Queue(maxsize=queue_size)
        self.stop_flag = False
        self.thread = None
        
    def _worker(self):
        for x_torch, p_torch, v_torch in self.dataloader:
            if self.stop_flag:
                break
            
            x = mx.array(x_torch.numpy()).astype(mx.float32)
            y_policy = mx.array(p_torch.numpy())
            y_value = mx.array(v_torch.numpy()).astype(mx.float32)
            
            self.queue.put((x, y_policy, y_value))
        
        self.queue.put(None)
    
    def __iter__(self):
        self.stop_flag = False
        self.thread = Thread(target=self._worker, daemon=True)
        self.thread.start()
        
        while True:
            item = self.queue.get()
            if item is None:
                break
            yield item
    
    def stop(self):
        self.stop_flag = True